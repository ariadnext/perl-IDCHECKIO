From 8b32c921204ec49a24e66d5029ceab6b1cdd8563 Mon Sep 17 00:00:00 2001
From: Denis Jagoudel <denis.jagoudel@ariadnext.com>
Date: Mon, 5 Dec 2016 15:49:21 +0100
Subject: [PATCH] Patch generated files

---
 lib/IdcheckioPerl/Client/ApiClient.pm              | 106 ++++++++++-----------
 .../Object/CheckSummaryOfTheSubmittedDocument.pm   |  25 ++---
 .../Object/ClassificationOfTheSubmittedDocument.pm |  25 ++---
 lib/IdcheckioPerl/Client/Object/ResultResponse.pm  |  30 +++---
 4 files changed, 97 insertions(+), 89 deletions(-)

diff --git a/lib/IdcheckioPerl/Client/ApiClient.pm b/lib/IdcheckioPerl/Client/ApiClient.pm
index 0fafacc..a459c76 100644
--- a/lib/IdcheckioPerl/Client/ApiClient.pm
+++ b/lib/IdcheckioPerl/Client/ApiClient.pm
@@ -25,7 +25,7 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
@@ -57,11 +57,11 @@ sub _new_instance
 {
     my $class = shift;
     my (%args) = (
-        'ua' => LWP::UserAgent->new,
+        'ua' => LWP::UserAgent->new(max_redirect => 0),
         'base_url' => 'https://localhost/rest',
         @_
     );
-  
+
     return bless \%args, $class;
 }
 
@@ -79,7 +79,7 @@ sub set_user_agent {
 # Set timeout
 #
 # @param integer $seconds Number of seconds before timing out [set to 0 for no timeout]
-# 
+#
 sub set_timeout {
     my ($self, $seconds) = @_;
     if (!looks_like_number($seconds)) {
@@ -98,40 +98,40 @@ sub set_timeout {
 sub call_api {
     my $self = shift;
     my ($resource_path, $method, $query_params, $post_params, $header_params, $body_data, $auth_settings) = @_;
-  
+
     # update parameters based on authentication settings
-    $self->update_params_for_auth($header_params, $query_params, $auth_settings); 
-  
-  
+    $self->update_params_for_auth($header_params, $query_params, $auth_settings);
+
+
     my $_url = $self->{base_url} . $resource_path;
-  
-    # build query 
+
+    # build query
     if (%$query_params) {
         $_url = ($_url . '?' . eval { URI::Query->new($query_params)->stringify });
     }
-  
-  
+
+
     # body data
     $body_data = to_json($body_data->to_hash) if defined $body_data && $body_data->can('to_hash'); # model to json string
     my $_body_data = %$post_params ? $post_params : $body_data;
-  
+
     # Make the HTTP request
     my $_request;
     if ($method eq 'POST') {
         # multipart
-        $header_params->{'Content-Type'} = lc $header_params->{'Content-Type'} eq 'multipart/form' ? 
+        $header_params->{'Content-Type'} = lc $header_params->{'Content-Type'} eq 'multipart/form' ?
             'form-data' : $header_params->{'Content-Type'};
-        
+
         $_request = POST($_url, %$header_params, Content => $_body_data);
-  
+
     }
     elsif ($method eq 'PUT') {
         # multipart
-        $header_params->{'Content-Type'}  = lc $header_params->{'Content-Type'} eq 'multipart/form' ? 
+        $header_params->{'Content-Type'}  = lc $header_params->{'Content-Type'} eq 'multipart/form' ?
             'form-data' : $header_params->{'Content-Type'};
-  
+
         $_request = PUT($_url, %$header_params, Content => $_body_data);
-  
+
     }
     elsif ($method eq 'GET') {
         my $headers = HTTP::Headers->new(%$header_params);
@@ -139,7 +139,7 @@ sub call_api {
     }
     elsif ($method eq 'HEAD') {
         my $headers = HTTP::Headers->new(%$header_params);
-        $_request = HEAD($_url,%$header_params); 
+        $_request = HEAD($_url,%$header_params);
     }
     elsif ($method eq 'DELETE') { #TODO support form data
         my $headers = HTTP::Headers->new(%$header_params);
@@ -149,20 +149,20 @@ sub call_api {
     }
     else {
     }
-   
-    $self->{ua}->timeout($self->{http_timeout} || $IdcheckioPerl::Client::Configuration::http_timeout); 
+
+    $self->{ua}->timeout($self->{http_timeout} || $IdcheckioPerl::Client::Configuration::http_timeout);
     $self->{ua}->agent($self->{http_user_agent} || $IdcheckioPerl::Client::Configuration::http_user_agent);
-    
+
     $log->debugf("REQUEST: %s", $_request->as_string);
     my $_response = $self->{ua}->request($_request);
     $log->debugf("RESPONSE: %s", $_response->as_string);
-  
-    unless ($_response->is_success) {
+
+    unless ($_response->is_success or $_response->{_rc} == 303) {
         croak(sprintf "API Exception(%s): %s\n%s", $_response->code, $_response->message, $_response->content);
     }
-       
+
     return $_response->content;
-  
+
 }
 
 #  Take value and turn it into a string suitable for inclusion in
@@ -227,7 +227,7 @@ sub to_string {
 }
 
 # Deserialize a JSON string into an object
-#  
+#
 # @param string $class class name is passed as a string
 # @param string $data data of the body
 # @return object an instance of $class
@@ -235,7 +235,7 @@ sub deserialize
 {
     my ($self, $class, $data) = @_;
     $log->debugf("deserializing %s for %s", $data, $class);
-  
+
     if (not defined $data) {
         return undef;
     } elsif ( (substr($class, 0, 5)) eq 'HASH[') { #hash
@@ -254,10 +254,10 @@ sub deserialize
         } else {
           #TODO log error
         }
-    
+
     } elsif ( (substr($class, 0, 6)) eq 'ARRAY[' ) { # array of data
         return $data if $data eq '[]'; # return if empty array
-    
+
         my $_sub_class = substr($class, 6, -1);
         my $_json_data = decode_json $data;
         my @_values = ();
@@ -281,7 +281,7 @@ sub deserialize
             return $_instance->from_hash(decode_json $data);
         }
     }
-  
+
 }
 
 # return 'Accept' based on an array of accept provided
@@ -290,7 +290,7 @@ sub deserialize
 sub select_header_accept
 {
     my ($self, @header) = @_;
-  
+
     if (@header == 0 || (@header == 1 && $header[0] eq '')) {
         return undef;
     } elsif (grep(/^application\/json$/i, @header)) {
@@ -298,7 +298,7 @@ sub select_header_accept
     } else {
         return join(',', @header);
     }
-  
+
 }
 
 # return the content type based on an array of content-type provided
@@ -307,7 +307,7 @@ sub select_header_accept
 sub select_header_content_type
 {
     my ($self, @header) = @_;
-  
+
     if (@header == 0 || (@header == 1 && $header[0] eq '')) {
         return 'application/json'; # default to application/json
     } elsif (grep(/^application\/json$/i, @header)) {
@@ -315,7 +315,7 @@ sub select_header_content_type
     } else {
         return join(',', @header);
     }
-  
+
 }
 
 # Get API key (with prefix if set)
@@ -326,24 +326,24 @@ sub get_api_key_with_prefix
 	my ($self, $key_name) = @_;
 
 	my $api_key = $IdcheckioPerl::Client::Configuration::api_key->{$key_name};
-	
+
 	return unless $api_key;
-	
+
 	my $prefix = $IdcheckioPerl::Client::Configuration::api_key_prefix->{$key_name};
 	return $prefix ? "$prefix $api_key" : $api_key;
-}	
+}
 
 # update header and query param based on authentication setting
-#  
+#
 # @param array $headerParams header parameters (by ref)
 # @param array $queryParams query parameters (by ref)
 # @param array $authSettings array of authentication scheme (e.g ['api_key'])
 sub update_params_for_auth {
     my ($self, $header_params, $query_params, $auth_settings) = @_;
-    
-    return $self->_global_auth_setup($header_params, $query_params) 
+
+    return $self->_global_auth_setup($header_params, $query_params)
     	unless $auth_settings && @$auth_settings;
-  
+
     # one endpoint can have more than 1 auth settings
     foreach my $auth (@$auth_settings) {
         # determine which one to use
@@ -351,7 +351,7 @@ sub update_params_for_auth {
             # TODO show warning about auth setting not defined
         }
         elsif ($auth eq 'basic') {
-            
+
             if ($IdcheckioPerl::Client::Configuration::username || $IdcheckioPerl::Client::Configuration::password) {
                 $header_params->{'Authorization'} = 'Basic ' . encode_base64($IdcheckioPerl::Client::Configuration::username . ":" . $IdcheckioPerl::Client::Configuration::password);
             }
@@ -362,27 +362,27 @@ sub update_params_for_auth {
     }
 }
 
-# The endpoint API class has not found any settings for auth. This may be deliberate, 
-# in which case update_params_for_auth() will be a no-op. But it may also be that the 
-# OpenAPI Spec does not describe the intended authorization. So we check in the config for any 
-# auth tokens and if we find any, we use them for all endpoints; 
+# The endpoint API class has not found any settings for auth. This may be deliberate,
+# in which case update_params_for_auth() will be a no-op. But it may also be that the
+# OpenAPI Spec does not describe the intended authorization. So we check in the config for any
+# auth tokens and if we find any, we use them for all endpoints;
 sub _global_auth_setup {
-	my ($self, $header_params, $query_params) = @_; 
-	
+	my ($self, $header_params, $query_params) = @_;
+
 	my $tokens = $self->_cfg->get_tokens;
 	return unless keys %$tokens;
-	
+
 	# basic
 	if (my $uname = delete $tokens->{username}) {
 		my $pword = delete $tokens->{password};
 		$header_params->{'Authorization'} = 'Basic '.encode_base64($uname.":".$pword);
 	}
-	
+
 	# oauth
 	if (my $access_token = delete $tokens->{access_token}) {
 		$header_params->{'Authorization'} = 'Bearer ' . $access_token;
 	}
-	
+
 	# other keys
 	foreach my $token_name (keys %$tokens) {
 		my $in = $tokens->{$token_name}->{in};
diff --git a/lib/IdcheckioPerl/Client/Object/CheckSummaryOfTheSubmittedDocument.pm b/lib/IdcheckioPerl/Client/Object/CheckSummaryOfTheSubmittedDocument.pm
index 612a885..bcd5ae3 100644
--- a/lib/IdcheckioPerl/Client/Object/CheckSummaryOfTheSubmittedDocument.pm
+++ b/lib/IdcheckioPerl/Client/Object/CheckSummaryOfTheSubmittedDocument.pm
@@ -25,7 +25,7 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
@@ -44,6 +44,7 @@ use DateTime;
 
 use base ("Class::Accessor", "Class::Data::Inheritable");
 
+use IdcheckioPerl::Client::Object::Control;
 
 #
 #
@@ -79,28 +80,28 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
 __PACKAGE__->mk_classdata('attribute_map' => {});
 __PACKAGE__->mk_classdata('swagger_types' => {});
-__PACKAGE__->mk_classdata('method_documentation' => {}); 
+__PACKAGE__->mk_classdata('method_documentation' => {});
 __PACKAGE__->mk_classdata('class_documentation' => {});
 
 # new object
-sub new { 
-    my ($class, %args) = @_; 
+sub new {
+    my ($class, %args) = @_;
 
 	my $self = bless {}, $class;
-	
+
 	foreach my $attribute (keys %{$class->attribute_map}) {
 		my $args_key = $class->attribute_map->{$attribute};
 		$self->$attribute( $args{ $args_key } );
 	}
-	
+
 	return $self;
-}  
+}
 
 # return perl hash
 sub to_hash {
@@ -108,7 +109,7 @@ sub to_hash {
 }
 
 # used by JSON for serialization
-sub TO_JSON { 
+sub TO_JSON {
     my $self = shift;
     my $_data = {};
     foreach my $_key (keys %{$self->attribute_map}) {
@@ -125,7 +126,7 @@ sub from_hash {
 
     # loop through attributes and use swagger_types to deserialize the data
     while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
-    	my $_json_attribute = $self->attribute_map->{$_key}; 
+    	my $_json_attribute = $self->attribute_map->{$_key};
         if ($_type =~ /^array\[/i) { # array
             my $_subclass = substr($_type, 6, -1);
             my @_array = ();
@@ -139,7 +140,7 @@ sub from_hash {
         	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
         }
     }
-  
+
     return $self;
 }
 
@@ -147,7 +148,7 @@ sub from_hash {
 sub _deserialize {
     my ($self, $type, $data) = @_;
     $log->debugf("deserializing %s with %s",Dumper($data), $type);
-        
+
     if ($type eq 'DateTime') {
         return DateTime->from_epoch(epoch => str2time($data));
     } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
diff --git a/lib/IdcheckioPerl/Client/Object/ClassificationOfTheSubmittedDocument.pm b/lib/IdcheckioPerl/Client/Object/ClassificationOfTheSubmittedDocument.pm
index 43bb414..2ef5ea7 100644
--- a/lib/IdcheckioPerl/Client/Object/ClassificationOfTheSubmittedDocument.pm
+++ b/lib/IdcheckioPerl/Client/Object/ClassificationOfTheSubmittedDocument.pm
@@ -25,7 +25,7 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
@@ -44,6 +44,7 @@ use DateTime;
 
 use base ("Class::Accessor", "Class::Data::Inheritable");
 
+use IdcheckioPerl::Client::Object::EventDate;
 
 #
 #
@@ -79,28 +80,28 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
 __PACKAGE__->mk_classdata('attribute_map' => {});
 __PACKAGE__->mk_classdata('swagger_types' => {});
-__PACKAGE__->mk_classdata('method_documentation' => {}); 
+__PACKAGE__->mk_classdata('method_documentation' => {});
 __PACKAGE__->mk_classdata('class_documentation' => {});
 
 # new object
-sub new { 
-    my ($class, %args) = @_; 
+sub new {
+    my ($class, %args) = @_;
 
 	my $self = bless {}, $class;
-	
+
 	foreach my $attribute (keys %{$class->attribute_map}) {
 		my $args_key = $class->attribute_map->{$attribute};
 		$self->$attribute( $args{ $args_key } );
 	}
-	
+
 	return $self;
-}  
+}
 
 # return perl hash
 sub to_hash {
@@ -108,7 +109,7 @@ sub to_hash {
 }
 
 # used by JSON for serialization
-sub TO_JSON { 
+sub TO_JSON {
     my $self = shift;
     my $_data = {};
     foreach my $_key (keys %{$self->attribute_map}) {
@@ -125,7 +126,7 @@ sub from_hash {
 
     # loop through attributes and use swagger_types to deserialize the data
     while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
-    	my $_json_attribute = $self->attribute_map->{$_key}; 
+    	my $_json_attribute = $self->attribute_map->{$_key};
         if ($_type =~ /^array\[/i) { # array
             my $_subclass = substr($_type, 6, -1);
             my @_array = ();
@@ -139,7 +140,7 @@ sub from_hash {
         	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
         }
     }
-  
+
     return $self;
 }
 
@@ -147,7 +148,7 @@ sub from_hash {
 sub _deserialize {
     my ($self, $type, $data) = @_;
     $log->debugf("deserializing %s with %s",Dumper($data), $type);
-        
+
     if ($type eq 'DateTime') {
         return DateTime->from_epoch(epoch => str2time($data));
     } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
diff --git a/lib/IdcheckioPerl/Client/Object/ResultResponse.pm b/lib/IdcheckioPerl/Client/Object/ResultResponse.pm
index 20c9f19..a1f6988 100644
--- a/lib/IdcheckioPerl/Client/Object/ResultResponse.pm
+++ b/lib/IdcheckioPerl/Client/Object/ResultResponse.pm
@@ -25,7 +25,7 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
@@ -44,6 +44,12 @@ use DateTime;
 
 use base ("Class::Accessor", "Class::Data::Inheritable");
 
+use IdcheckioPerl::Client::Object::Mrz;
+use IdcheckioPerl::Client::Object::ClassificationOfTheSubmittedDocument;
+use IdcheckioPerl::Client::Object::ControlGroup;
+use IdcheckioPerl::Client::Object::DetailedInformationOfTheHolderOfTheSubmittedDocument;
+use IdcheckioPerl::Client::Object::DetailedInformationOfTheSubmittedDocument;
+use IdcheckioPerl::Client::Object::CheckSummaryOfTheSubmittedDocument;
 
 #
 #
@@ -79,28 +85,28 @@ limitations under the License.
 =cut
 
 #
-# NOTE: This class is auto generated by the swagger code generator program. 
+# NOTE: This class is auto generated by the swagger code generator program.
 # Do not edit the class manually.
 # Ref: https://github.com/swagger-api/swagger-codegen
 #
 __PACKAGE__->mk_classdata('attribute_map' => {});
 __PACKAGE__->mk_classdata('swagger_types' => {});
-__PACKAGE__->mk_classdata('method_documentation' => {}); 
+__PACKAGE__->mk_classdata('method_documentation' => {});
 __PACKAGE__->mk_classdata('class_documentation' => {});
 
 # new object
-sub new { 
-    my ($class, %args) = @_; 
+sub new {
+    my ($class, %args) = @_;
 
 	my $self = bless {}, $class;
-	
+
 	foreach my $attribute (keys %{$class->attribute_map}) {
 		my $args_key = $class->attribute_map->{$attribute};
 		$self->$attribute( $args{ $args_key } );
 	}
-	
+
 	return $self;
-}  
+}
 
 # return perl hash
 sub to_hash {
@@ -108,7 +114,7 @@ sub to_hash {
 }
 
 # used by JSON for serialization
-sub TO_JSON { 
+sub TO_JSON {
     my $self = shift;
     my $_data = {};
     foreach my $_key (keys %{$self->attribute_map}) {
@@ -125,7 +131,7 @@ sub from_hash {
 
     # loop through attributes and use swagger_types to deserialize the data
     while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
-    	my $_json_attribute = $self->attribute_map->{$_key}; 
+    	my $_json_attribute = $self->attribute_map->{$_key};
         if ($_type =~ /^array\[/i) { # array
             my $_subclass = substr($_type, 6, -1);
             my @_array = ();
@@ -139,7 +145,7 @@ sub from_hash {
         	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
         }
     }
-  
+
     return $self;
 }
 
@@ -147,7 +153,7 @@ sub from_hash {
 sub _deserialize {
     my ($self, $type, $data) = @_;
     $log->debugf("deserializing %s with %s",Dumper($data), $type);
-        
+
     if ($type eq 'DateTime') {
         return DateTime->from_epoch(epoch => str2time($data));
     } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
-- 
2.9.3 (Apple Git-75)

